<?php

/** 
 * Author: Eugen Mayer (http://kontextwork.de)
 * Converted from D6 to D7 by iStryker
 */
 
/**
 * Implements hook_help().
 */
function tagging_help($path, $arg) {
  switch ($path) {
    case 'admin/help#tagging':
      return t('Tagging offers a javascript user interface to add free tagging to content.  If you install additional submodules then it also makes suggestion for you.');
  }
}

/**
 * Implements hook_init().
 */
function tagging_init() {
}
 
/**
 * Implements hook_menu().
 */
function tagging_menu() {
  $items = array();
  $items['admin/config/content/tagging'] = array(
        'title' => 'Tagging configuration',
        'description' => 'Configuration options for the tagging module',
        'page callback' => 'drupal_get_form',
        'page arguments' => array('tagging_admin_settings'),
        'access callback' => 'user_access',
        'access arguments' => array('administer site configuration'),
        'file' => 'tagging.admin.inc',
        'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Implements hook_field_widget_info().
 */
function tagging_field_widget_info() {
  return array(
    'tagging_taxonomy_autocomplete' => array(
      'label' => t('Tagging module autocomplete javascript UI widget'),
      'field types' => array('taxonomy_term_reference'),
      'settings' => array(
        'size' => 40,
        'autocomplete_path' => 'taxonomy/autocomplete',
      ),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
      ),
    ),
  );
}
/**
 * Implements hook_field_widget_form().
 */
function tagging_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  // dsm($instance);
  // dsm($element);
  // dsm($items);
  // dsm($field);
  // dsm($form);
  $settings = $instance['widget']['settings'];
  
  $element += array(
    '#type' => 'item',
    '#markup' => '',
    '#element_validate' => array('tagging_taxonomy_autocomplete_validate'),
	'#attributes' => array('class' => 'tagging-widget-input-wrapper', 'clearfix'),
  );
  // iStryker April 7th, 2011: maybe a problem in the future.  only 1 allowed value is allowed so far. 
  // there is an option for parent, which I have no clue what it is for
  $machine_name = $field['settings']['allowed_values'][0]['vocabulary']; 
  
  //query database to get the vocabulary id
  $vids = db_query('SELECT tv.vid FROM {taxonomy_vocabulary} tv WHERE tv.machine_name = :machine_name', array(':machine_name' => $machine_name));
  //I don't know if I need to foreach here, but it doesn't break anything.  Could allow multiple vocabularys in the future
  //Pulled from Example #1 of http://api.drupal.org/api/drupal/includes--database--database.inc/function/db_query/7
  foreach ($vids as $vid) {
    if (!empty($instance['description'] )) {
      $description = t($instance['description']);
    }
    else {
      $description = t('Type and press enter to add the tag');
    }
  
    $tags = array();
    foreach ($items as $item) {
      $tags[$item['tid']] = isset($item['taxonomy_term']) ? $item['taxonomy_term'] : taxonomy_term_load($item['tid']);
    }
  
  
    // order (temporary comments)
    // Active Tags: term1(x), term2(x), etc
    // Textfield (autocomplete),  Add button
    // Suggestions
  
    $element[$vid->vid]['field_terms'] = array(
      '#markup' => theme('tagging_tags_list', array('tags' => $tags, 'vid' => $vid->vid)),
    );
    $element[$vid->vid]['term_entry'] = array(
      '#type' => 'textfield',
      '#default_value' => '',
      '#autocomplete_path' => $settings['autocomplete_path'] . '/' . $field['field_name'],
      '#size' => $settings['size'],
      '#maxlength' => 1024,
      '#attributes' => array(
        'class' => array(
          'tagging-widget-input',
          'tagging-widget-input-' . $vid->vid,
        ),
        'id' => 'tagging-widget-input-' . $vid->vid,
      ),
	  '#description' => $description,
	  '#field_suffix' => '<a class="tagging-button-container" href="#" title="'.t('Add').'"><span class="tagging-button tagging-button-' . $vid->vid . '"></span></a>',
      '#theme_wrappers' => array(),
    );
    // $element[$vid->vid]['add_button'] = array(
      // '#type' => 'button',
      // '#value' => t('Add'),
      // '#attributes' => array('class' => array('tagging-button', "tagging-button-" . $vid->vid . ")),
    // );
  
    // add suggestions here
    $element[$vid->vid]['suggestions']['#value'] = _tagging_add_suggestions( array(
        'nid' => $form['nid']['#value'],
	    'vid' => $vid->vid,
      )
    );
    // dsm('after tagging add suggestions');
    // dsm($element[$vid->vid]['suggestions']);
    $element[$vid->vid]['suggestions']['#markup'] = theme('tagging_suggestions_list', array('suggestions' => $element[$vid->vid]['suggestions']['#value'], 'vid' => $vid->vid));
    // We actually just need it in the background, so that we dont need to fight in the 
    // validation filter. We can let the normal taxonomy.module validators and submitters do their job.
    $element[$vid->vid]['terms'] = array(
      '#type' => 'hidden',
      '#default_value' => taxonomy_implode_tags($tags),
      '#size' => $settings['size'],
      '#maxlength' => 1024,
      //'#element_validate' => array('active_tags_taxonomy_autocomplete_validate'),
      '#attributes' => array('class' => array('tagging-widget-target-' . $vid->vid)),
      '#theme_wrappers' => array(),
    );
    // dsm('afterwards');
    // dsm($element);
  }
  drupal_add_css(drupal_get_path('module', 'tagging') . '/css/tagging.css');
  drupal_add_js(drupal_get_path('module', 'tagging') . '/js/tagging.init.js');
  drupal_add_js(drupal_get_path('module', 'tagging') . '/js/tagging.plugin.js');
  return $element;
}

/**
 * Implements hook_field_widget_settings_form().
 */
function tagging_field_widget_settings_form($field, $instance) {
  // dsm($field);
  // dsm($instance);
}
/**
 * Implements hook_field_widget_error().
 */
function tagging_field_widget_error($element, $error, $form, &$form_state) {
  form_error($element, $error['message']);
}

function tagging_taxonomy_autocomplete_validate($element, &$form_state) {
  $element['#value'] = $element['terms']['#value'];
  taxonomy_autocomplete_validate($element, $form_state);
}

// /**
 // * Implements hook_elements_info().
 // * Registering the new form element, so we can render the tagging form element properly
 // */
// function tagging_elements_info() {
  // $type['tagging_widget'] = array(
    // '#input' => TRUE,
    // '#after_build' => array('_tagging_widget_javascript'),
    // '#process' => array('_tagging_add_suggestions'),
    // '#default_value' => -1,
  // );
  // return $type;
// }

// /**
 // * Implements of hook_form_alter().
 // */
// function tagging_form_alter(&$form, &$form_state, $form_id) {
  // dsm($form);
  // // Check if we are editting a node and we actually have a tag taxonomy.
  // if ($form['#node_edit_form'] == TRUE && isset($form['taxonomy']['tags'])) {
    // foreach ($form['taxonomy']['tags'] as $id => $values) {
      // if (variable_get('tagging_inject_' . $id, 0) == 1) {
	    
        // $form['taxonomy']['tags'][$id]['#type'] = 'tagging_widget';
        // $form['taxonomy']['tags'][$id]['#vid'] = $id;
        // $form['taxonomy']['tags'][$id]['#nid'] = $form['nid']['#value'];
      // }
    // }
  // }
  // if (isset($form['field_tags']) && variable
  // // Check if user_terms is present
  // if (isset($form['user_terms'])) {
    // // Iterate all the available vocabularies
    // foreach ($form['user_terms'] as $key => $value) {
      // // Only act on form items containing vocabularies
      // if (strstr($key, 'user_terms_')) {
        // // Extract the vid
        // $id = str_replace('user_terms_', '', $key);
        // // Make sure it's numeric
        // if (is_numeric($id)) {
          // // Check if the tagging widget is enabled for this
          // if (variable_get('tagging_inject_' . $id, 0)) {
            // $form['user_terms'][$key]['#type'] = 'tagging_widget';
            // $form['user_terms'][$key]['#vid'] = $id;
            // $form['user_terms'][$key]['#uid'] = $form['#uid'];
          // }
        // }
      // }
    // }
  // }
// }

// /**
 // * Implements of hook_form_ID_alter().
 // */
// function tagging_form_taxonomy_form_vocabulary_alter(&$form, $form_state ) {
  // $form['settings']['tagging_inject'] = array(
    // '#type' => 'checkbox',
    // '#title' => t('Tagging Widget'),
    // '#weight' => 10,
    // '#default_value' => variable_get('tagging_inject_' . $form['vid']['#value'], 0),
    // '#description' => t('Use the visual tagging-widget, when this taxonomy is shown to the user'),
  // );
  // $form['#submit'][] = 'tagging_form_vocabulary_submit';
// }

/**
 * Implements hook_theme().
 */
function tagging_theme() {
  return array(
    'tagging_widget' => array('arguments' => array('element' => NULL) ),
    'tagging_widget_button' => array('arguments' => array('vid' => NULL) ),
    'tagging_widget_wrapper' => array('arguments' => array('content' => NULL, 'vid' => NULL) ),
    'tagging_suggestions_list' => array(
	  'variables' => array('suggestions' => array(), 'vid' => NULL )
	),
    'tagging_tags_list' => array(
	  'variables' => array('tags' => array(), 'vid' => NULL) 
    ),	 
  );
}

/**
 * Rendering the tagging widget.
 */
function theme_tagging_widget($element) {
  // TODO: Maybe use a file as a template..but otherwise...performance?
  $vid = $element['#vid'];
  $cur_tags = '';

  $id = "tagging-widget-input-$vid";
  $fieldset['#title'] = $element['#title'];
  $fieldset['#collapsed'] = FALSE;
  // Well this is the original. We actually just need it in the background, so that we
  // dont need to fight in the validation filter. We can let the normal taxonomy.modul
  // validators and submitters do their job.
  $element['#type'] = 'hidden';
  $element['#attributes']['class'] = "tagging-widget-target-$vid";
  $old_input = theme('hidden', $element);

  // Ok now lets render the input textfield we will use for the tagging
  $element['#type'] = 'textfield';
  // Its convention that the tagging-widget-VID class it addid. That vid will be used
  // to get the unique "context" id for all the other wrappers and functions.
  $element['#attributes']['class'] = "tagging-widget-input $id";
  $element['#id']= $id;
  $element['#title']= "";

  if ($element['#description'] == '') {
    $element['#description'] = t("Type and press enter to add the tag");
  }
  $element['#field_suffix'] = theme('tagging_widget_button', $vid) . $old_input;
  $output .= theme('tagging_tags_list', split(',', $element['#value']), $vid)
            . '<div class="taggin-widget-input-wrapper clearfix">'
            . theme('textfield', $element)
            . '</div>'
            . theme('tagging_suggestions_list', $element['#suggestions'], $vid);
  $fieldset['#value'] = $output;
  $output = theme('fieldset', $fieldset);
  return theme('tagging_widget_wrapper', $output, $vid);
}

/**
 * Rendering the widget button
 */
function theme_tagging_widget_button($vid) {
  return '<a class="tagging-button-container" href="#" title="' . t('Add') . '"><span class="tagging-button tagging-button-' . $vid . '"></span></a>';
}

/**
 * Rendering the wrapper of the widget
 */
function theme_tagging_widget_wrapper($content, $vid) {
  return "<div id='tagging-widget-container'>$content</div>";
}

/**
 * Rendering suggestions for a specific vocabulary
 */
function theme_tagging_tags_list($variables) {
  $cur_tags = '';  
  // they are sorted already
  foreach ($variables['tags'] as $term) {
    if ($term == '') {
      continue;
    }
    // TODO: use # here...but out of any reason it gets encoded to %23 in html
    // using trim here, as mostly the old tagging system was "one, two, three"..
    $term = "<span class='tagging-tag' id=tagging-tag-" . $term->tid . "'>" . _tagging_check_tag($term->name) . "</span>";

	// iStryker TODO: I believe l function has change for 7
    $link = l($term, '', array('html' => TRUE, 'attributes' => array('title' => t('Remove tag'), 'fragment' => '#')));
    $cur_tags .= $link;
  }
  return "<div class='tagging-curtags-wrapper tagging-curtags-wrapper-" . $variables['vid'] . "'><label>" . t('Assigned Tags:') . "</label>$cur_tags</div>";
}

function _tagging_check_tag($tag) {
  $tag = trim(check_plain($tag));
  return $tag;
}

/**
 * Rendering suggestions
 * we need $vid for namespacing only
 */
function theme_tagging_suggestions_list($variables) {
    $suggested_tags = '';
    // They are sorted already.
    foreach ($variables['suggestions'] as $term) {
      if ($term['#name'] == '') {
        continue;
      }
      // TODO: Use # here...but out of any reason it gets encoded to %23 in html.
      $title = t('Add this already existing tag');
      $class = 'tagging-suggest-tag';
      if (array_key_exists('#new', $term) && $term['#new'] == TRUE) {
        $class .= ' tagging-suggestion-new';
		// iStryker TODO:  $title, gets call all the time, I think it should only be once
        $title = t('Add this new tag');
      }
      $term = "<span id='tagging-" . $variables['vid'] . "' class='{$class}'>" . _tagging_check_tag($term['#name']) . "</span>";
	  // iStryker TODO: I believe l function has change for 7
      $link = l($term, '', array('html' => TRUE, 'attributes' => array('title' => $title )));
      $suggested_tags .= $link;
    }
    // If we have any suggestions, then place the wrapper.
    if ($suggested_tags != '') {
      return "<div class='tagging-suggestions-wrapper tagging-suggestions-wrapper-" . $variables['vid'] . "'><label>"
                                . t('Suggestions') . ":</label>$suggested_tags</div>";
    }
    // We have no suggestions, so no need to show any output
    return '';
}

/**
 * Defining new hook: hook_tagging_suggestion
 * Modules can use this hook to implement their methods to provide suggestions for tagging
 * the current node
 */
function _tagging_add_suggestions($variables) {
  // TODO: Quite expensive here. Should we only fetch the body? This might
  // change in the future
  $node = node_load($variables['nid']);
  /*
  * @vid: This is the vid the suggestions have been called for. You can use this to decide whether you
  *       want to suggest something or not for this vocabulary
  * @node: This is the complete expanded node object. Use this to e.g. base your suggestions on the body
  *        of the node or the title or whatever you wish on
  */ 
  // dsm('suggestions in add suggestions');
  $suggestions = module_invoke_all('tagging_suggestions', $variables['vid'], $node);
  // dsm($suggestions);
  drupal_alter('tagging_suggestions', $suggestions);
  
  // dsm($suggestions);
  // Validation
  if ( !is_array($suggestions) ) {
    // dsm('no suggestions');
    $suggestions = array();
    watchdog(WATCHDOG_WARNING, 'Tagging: Could not parse suggestion array - maybe some hooks are out of bound?');
  }
  // Iam not going to hold the devs hand and validate if we got a valid array with #name / #weight
  uasort($suggestions, 'element_sort');
  // Only show a maximum ammount of suggesitons
  if (variable_get('tagging_show_max_suggestion', 20) > 0) {
    $suggestions = array_slice($suggestions, 0, variable_get('tagging_show_max_suggestion', 20));
  }
  
  $new_field = $suggestions;
  return $new_field;
}


// /**
 // * Implementing #process of the form element tagging_widget.
 // * Adding Javascript-Libraries needed, if a widget has been placed.
 // */
// function _tagging_widget_javascript($form_element, &$form_state) {
  // drupal_add_css(drupal_get_path('module', 'tagging') . '/css/tagging.css', 'module');
  // drupal_add_js(drupal_get_path('module', 'tagging') . '/js/tagging.plugin.js', 'module');
  // drupal_add_js(drupal_get_path('module', 'tagging') . '/js/tagging.init.js', 'module');
  // return $form_element;
// }

// /**
 // * Saving the variable, whether to show the widget for a taxonomy or not
 // */
// function tagging_form_vocabulary_submit($form, &$form_state) {
  // // set global variable for this taxomony vocabulary
  // variable_set('tagging_inject_' . $form_state['values']['vid'], $form_state['values']['tagging_inject']);
  // return TRUE;
// }
